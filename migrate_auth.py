"""
Authentication Migration Script
===============================

This script safely migrates from the old oauth_routes.py to the new unified auth system.
Updated with UTF-8 encoding support for cross-platform compatibility.
"""

import os
import shutil
import argparse
from datetime import datetime
from pathlib import Path
from typing import Optional


class AuthMigration:
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.auth_dir = self.project_root / "app" / "auth"
        self.backup_dir = self.project_root / "backups" / f"auth_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        self.files_to_backup = [
            self.auth_dir / "oauth_routes.py",
            self.auth_dir / "middleware.py",
            self.project_root / "app" / "app.py"
        ]
        
    def create_backup(self):
        """Create backup of existing files"""
        print(f"\nüì¶ Creating backup in {self.backup_dir}...")
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        for file_path in self.files_to_backup:
            if file_path.exists():
                backup_path = self.backup_dir / file_path.name
                shutil.copy2(file_path, backup_path)
                print(f"  ‚úì Backed up {file_path.name}")
            else:
                print(f"  ‚ö† Skipped {file_path.name} (not found)")
        
        print(f"‚úÖ Backup completed at: {self.backup_dir}\n")
    
    def merge_oauth_routes(self):
        """Merge old OAuth routes with new auth system"""
        print("üîß Merging OAuth routes with new auth system...")
        
        old_oauth_path = self.auth_dir / "oauth_routes.py"
        new_auth_path = self.auth_dir / "auth_routes.py"
        
        if not old_oauth_path.exists():
            print("  ‚ö† oauth_routes.py not found, creating new auth_routes.py from template")
            self._create_new_auth_routes()
            return
        
        # Fixed: Explicitly using utf-8 encoding to prevent UnicodeDecodeError
        with open(old_oauth_path, 'r', encoding='utf-8') as f:
            old_content = f.read()
        
        # Create merged auth_routes.py
        merged_content = self._generate_merged_routes(old_content)
        
        with open(new_auth_path, 'w', encoding='utf-8') as f:
            f.write(merged_content)
        
        print(f"  ‚úì Created merged auth_routes.py")
        print(f"  ‚úì Old oauth_routes.py preserved as backup\n")
    
    def _generate_merged_routes(self, old_oauth_content: str) -> str:
        """Generate merged auth routes preserving custom OAuth logic"""
        
        # Extract the OAuth login and callback functions from old file
        oauth_login_func = self._extract_function(old_oauth_content, "oauth_login")
        oauth_callback_func = self._extract_function(old_oauth_content, "oauth_callback")
        
        return f'''"""
Unified Authentication Routes
Generated by migration script on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Combines OAuth (Google Calendar) and Email/Password authentication
"""

from fastapi import APIRouter, Request, HTTPException, Response
from fastapi.responses import RedirectResponse, JSONResponse, HTMLResponse, FileResponse
from pydantic import BaseModel, EmailStr
from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build
from app.config import settings
from app.services.firebase_service import firebase_service
from typing import Optional
import os

router = APIRouter(prefix="/auth", tags=["authentication"])


# ==================== MODELS ====================

class EmailPasswordLogin(BaseModel):
    """Email/password login credentials"""
    email: EmailStr
    password: str
    account_type: str  # "doctor" or "hospital"


class TokenVerification(BaseModel):
    """Firebase token verification"""
    id_token: str
    account_type: str


# ==================== EMAIL/PASSWORD AUTHENTICATION ====================

@router.post("/login/email")
async def login_with_email_password(credentials: EmailPasswordLogin, response: Response):
    """
    Login with email and password
    Used primarily for hospital admins
    """
    try:
        if credentials.account_type == "hospital":
            hospital = await firebase_service.get_hospital_by_email(credentials.email)
            if not hospital:
                raise HTTPException(status_code=401, detail="Invalid credentials")
            
            response.set_cookie(
                key=settings.SESSION_COOKIE_NAME,
                value=hospital["id"],
                max_age=settings.SESSION_MAX_AGE,
                httponly=True,
                samesite="lax",
                secure=settings.IS_PRODUCTION
            )
            
            return {{
                "success": True,
                "user_type": "hospital",
                "redirect_url": "/hospital/dashboard",
                "user": {{
                    "id": hospital["id"],
                    "name": hospital["name"],
                    "email": hospital["email"]
                }}
            }}
            
        elif credentials.account_type == "doctor":
            doctor = await firebase_service.get_doctor_by_email(credentials.email)
            if not doctor:
                raise HTTPException(status_code=401, detail="Invalid credentials")
            
            response.set_cookie(
                key=settings.SESSION_COOKIE_NAME,
                value=doctor["id"],
                max_age=settings.SESSION_MAX_AGE,
                httponly=True,
                samesite="lax",
                secure=settings.IS_PRODUCTION
            )
            
            return {{
                "success": True,
                "user_type": "doctor",
                "redirect_url": "/doctor/dashboard",
                "user": {{
                    "id": doctor.get("id"),
                    "name": doctor["name"],
                    "email": doctor["email"]
                }}
            }}
        else:
            raise HTTPException(status_code=400, detail="Invalid account type")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Login error: {{e}}")
        raise HTTPException(status_code=500, detail=str(e))


# ==================== GOOGLE OAUTH (PRESERVED FROM OLD IMPLEMENTATION) ====================

{oauth_login_func if oauth_login_func else self._get_default_oauth_login()}

{oauth_callback_func if oauth_callback_func else self._get_default_oauth_callback()}


# ==================== LOGOUT ====================

@router.post("/logout")
async def logout(response: Response):
    """Logout user by clearing session cookie"""
    response.delete_cookie(
        key=settings.SESSION_COOKIE_NAME,
        httponly=True,
        samesite="lax",
        secure=settings.IS_PRODUCTION
    )
    return {{"success": True, "message": "Logged out successfully"}}


@router.get("/logout")
async def logout_get(response: Response):
    """Logout via GET (for direct links)"""
    response.delete_cookie(
        key=settings.SESSION_COOKIE_NAME,
        httponly=True,
        samesite="lax",
        secure=settings.IS_PRODUCTION
    )
    return RedirectResponse(url="/")


# ==================== SESSION MANAGEMENT ====================

@router.get("/session")
async def get_session(request: Request):
    """Get current session info"""
    session_id = request.cookies.get(settings.SESSION_COOKIE_NAME)
    
    if not session_id:
        return {{"authenticated": False}}
    
    # Check if it's a doctor
    doctor = await firebase_service.get_doctor(session_id)
    if doctor:
        return {{
            "authenticated": True,
            "user_type": "doctor",
            "user": {{
                "id": session_id,
                "name": doctor.get("name"),
                "email": doctor.get("email"),
                "calendar_connected": bool(doctor.get("refresh_token"))
            }}
        }}
    
    # Check if it's a hospital
    hospital = await firebase_service.get_hospital(session_id)
    if hospital:
        return {{
            "authenticated": True,
            "user_type": "hospital",
            "user": {{
                "id": session_id,
                "name": hospital.get("name"),
                "email": hospital.get("email")
            }}
        }}
    
    return {{"authenticated": False}}


# ==================== LOGIN PAGE ====================

@router.get("/login/page", response_class=HTMLResponse)
async def login_page():
    """Serve login page"""
    try:
        static_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "static")
        login_path = os.path.join(static_dir, "login.html")
        
        if os.path.exists(login_path):
            return FileResponse(login_path)
    except:
        pass
    
    # Inline fallback
    return HTMLResponse(content="""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - CareCoordinator</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }}
        .container {{
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            max-width: 400px;
            width: 100%;
        }}
        h1 {{ color: #333; margin-bottom: 30px; text-align: center; }}
        input, select {{
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }}
        button {{
            width: 100%;
            padding: 14px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
        }}
        button:hover {{ background: #5568d3; }}
        .error {{
            background: #fed7d7;
            color: #742a2a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }}
        .links {{ text-align: center; margin-top: 20px; }}
        .links a {{ color: #667eea; text-decoration: none; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üè• Sign In</h1>
        <div id="error" class="error"></div>
        <form id="loginForm">
            <select name="account_type" required>
                <option value="doctor">Doctor</option>
                <option value="hospital">Hospital Admin</option>
            </select>
            <input type="email" name="email" placeholder="Email" required>
            <input type="password" name="password" placeholder="Password" required>
            <button type="submit">Sign In</button>
        </form>
        <div class="links">
            <a href="/signup/hospital">Register Hospital</a> | 
            <a href="/signup/doctor">Register Doctor</a>
        </div>
    </div>
    <script>
        document.getElementById('loginForm').addEventListener('submit', async (e) => {{
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            
            try {{
                const response = await fetch('/auth/login/email', {{
                    method: 'POST',
                    headers: {{ 'Content-Type': 'application/json' }},
                    body: JSON.stringify(data)
                }});
                
                const result = await response.json();
                
                if (response.ok) {{
                    window.location.href = result.redirect_url;
                }} else {{
                    document.getElementById('error').textContent = result.detail || 'Login failed';
                    document.getElementById('error').style.display = 'block';
                }}
            }} catch (error) {{
                document.getElementById('error').textContent = 'Network error';
                document.getElementById('error').style.display = 'block';
            }}
        }});
    </script>
</body>
</html>
    """)
'''
    
    def _extract_function(self, content: str, func_name: str) -> Optional[str]:
        """Extract a function definition from Python code"""
        lines = content.split('\n')
        func_lines = []
        in_function = False
        indent_level = 0
        
        for line in lines:
            if f'def {func_name}' in line or f'async def {func_name}' in line:
                in_function = True
                indent_level = len(line) - len(line.lstrip())
                func_lines.append(line)
            elif in_function:
                current_indent = len(line) - len(line.lstrip())
                
                # Check if we've exited the function
                if line.strip() and current_indent <= indent_level and not line.strip().startswith('@'):
                    break
                
                func_lines.append(line)
        
        return '\n'.join(func_lines) if func_lines else None
    
    def _get_default_oauth_login(self) -> str:
        """Default OAuth login function if extraction fails"""
        return '''@router.get("/login")
async def oauth_login(request: Request):
    """Initiate Google OAuth flow for calendar access"""
    if not settings.IS_PRODUCTION:
        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'
    
    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRETS_FILE,
        scopes=settings.GOOGLE_SCOPES,
        redirect_uri=settings.REDIRECT_URI
    )
    
    hospital_id = request.query_params.get("hospital_id")
    temp_id = request.query_params.get("temp_id")
    custom_state = f"{hospital_id or 'none'}|{temp_id or 'none'}"

    authorization_url, state = flow.authorization_url(
        access_type='offline',
        include_granted_scopes='true',
        prompt='consent',
        state=custom_state
    )
    
    return RedirectResponse(authorization_url)'''
    
    def _get_default_oauth_callback(self) -> str:
        """Default OAuth callback function if extraction fails"""
        return '''@router.get("/callback")
async def oauth_callback(request: Request):
    """Handle Google OAuth callback"""
    code = request.query_params.get("code")
    state = request.query_params.get("state")
    
    if not code:
        raise HTTPException(status_code=400, detail="No authorization code provided")
    
    hospital_id = None
    temp_id = None
    if state and "|" in state:
        h_id, t_id = state.split("|")
        hospital_id = h_id if h_id != 'none' else None
        temp_id = t_id if t_id != 'none' else None

    try:
        if not settings.IS_PRODUCTION:
            os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'
        
        flow = Flow.from_client_secrets_file(
            settings.GOOGLE_CLIENT_SECRETS_FILE,
            scopes=settings.GOOGLE_SCOPES,
            redirect_uri=settings.REDIRECT_URI
        )
        
        flow.fetch_token(code=code)
        creds = flow.credentials
        
        oauth_service = build('oauth2', 'v2', credentials=creds)
        user_info = oauth_service.userinfo().get().execute()
        
        doctor_id = f"doctor_{user_info['id']}"
        
        doctor_data = {
            "name": user_info.get('name', 'Unknown'),
            "email": user_info['email'],
            "profile_pic": user_info.get('picture', ''),
            "token": creds.token,
            "refresh_token": creds.refresh_token,
            "token_uri": creds.token_uri,
            "client_id": creds.client_id,
            "client_secret": creds.client_secret,
            "scopes": creds.scopes,
        }
        
        if temp_id:
            temp_data = await firebase_service.get_doctor(temp_id)
            if temp_data:
                doctor_data.update({
                    "specialty": temp_data.get("specialty"),
                    "hospital_id": temp_data.get("hospital_id"),
                })
        
        if hospital_id:
            doctor_data["hospital_id"] = hospital_id
        
        success = await firebase_service.save_doctor_credentials(doctor_id, doctor_data)
        
        if not success:
            raise HTTPException(status_code=500, detail="Failed to save credentials")
        
        response = RedirectResponse(url=f"{settings.FRONTEND_URL}/doctor/dashboard")
        response.set_cookie(
            key=settings.SESSION_COOKIE_NAME,
            value=doctor_id,
            max_age=settings.SESSION_MAX_AGE,
            httponly=True,
            samesite="lax",
            secure=settings.IS_PRODUCTION
        )
        return response
        
    except Exception as e:
        print(f"OAuth callback error: {e}")
        return JSONResponse(
            content={"error": "Authentication failed", "detail": str(e)},
            status_code=500
        )'''
    
    def _create_new_auth_routes(self):
        """Create new auth routes file from template"""
        new_auth_path = self.auth_dir / "auth_routes.py"
        
        content = self._generate_merged_routes("")
        
        with open(new_auth_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"  ‚úì Created new auth_routes.py")
    
    def update_app_imports(self):
        """Update app.py to use new auth routes"""
        print("üìù Updating app.py imports...")
        
        app_path = self.project_root / "app" / "app.py"
        
        if not app_path.exists():
            print("  ‚ö† app.py not found, skipping import update")
            return
        
        with open(app_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Replace old import
        if 'from app.auth.oauth_routes import router as auth_router' in content:
            content = content.replace(
                'from app.auth.oauth_routes import router as auth_router',
                'from app.auth.auth_routes import router as auth_router  # Migrated to unified auth'
            )
            print("  ‚úì Updated oauth_routes import to auth_routes")
        elif 'from app.auth.oauth_routes' in content:
            print("  ‚ö† Found oauth_routes import but couldn't auto-replace")
            print("    Please manually update: from app.auth.auth_routes import router as auth_router")
        else:
            print("  ‚Ñπ No oauth_routes import found, you may need to add:")
            print("    from app.auth.auth_routes import router as auth_router")
            print("    app.include_router(auth_router)")
        
        with open(app_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print("  ‚úì app.py updated\n")
    
    def update_middleware(self):
        """Update middleware.py to new version"""
        print("üîß Updating middleware.py...")
        
        middleware_path = self.auth_dir / "middleware.py"
        
        # New middleware content
        new_middleware = '''from fastapi import Request, HTTPException, status
from fastapi.responses import RedirectResponse
from typing import Optional
from app.config import settings
from app.services.firebase_service import firebase_service


async def get_current_user(request: Request) -> Optional[dict]:
    """Get current authenticated user (doctor or hospital) from session cookie"""
    user_id = request.cookies.get(settings.SESSION_COOKIE_NAME)
    
    if not user_id:
        return None
    
    if user_id.startswith("doctor_"):
        doctor = await firebase_service.get_doctor(user_id)
        if doctor:
            return {"type": "doctor", "id": user_id, "data": doctor}
    
    if user_id.startswith("hospital_"):
        hospital = await firebase_service.get_hospital(user_id)
        if hospital:
            return {"type": "hospital", "id": user_id, "data": hospital}
    
    return None


async def get_current_doctor(request: Request) -> Optional[str]:
    """Get current authenticated doctor ID from session cookie"""
    user = await get_current_user(request)
    if user and user["type"] == "doctor":
        return user["id"]
    return None


async def require_doctor_auth(request: Request) -> str:
    """Dependency that requires doctor authentication"""
    doctor_id = await get_current_doctor(request)
    
    if not doctor_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated as a doctor"
        )
    
    doctor = await firebase_service.get_doctor(doctor_id)
    if not doctor:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid session"
        )
    
    return doctor_id


async def require_hospital_auth(request: Request) -> str:
    """Dependency that requires hospital admin authentication"""
    user = await get_current_user(request)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    if user["type"] == "hospital":
        return user["id"]
    
    if user["type"] == "doctor":
        doctor = user["data"]
        hospital_id = doctor.get("hospital_id")
        
        if not hospital_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="No hospital associated with this account"
            )
        
        hospital = await firebase_service.get_hospital(hospital_id)
        if not hospital:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Hospital not found"
            )
        
        return hospital_id
    
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail="Not authorized to access hospital data"
    )


async def require_auth(request: Request) -> dict:
    """Dependency that requires any authentication (doctor or hospital)"""
    user = await get_current_user(request)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )
    
    return user


async def optional_auth(request: Request) -> Optional[dict]:
    """Dependency that allows optional authentication"""
    return await get_current_user(request)
'''
        
        with open(middleware_path, 'w', encoding='utf-8') as f:
            f.write(new_middleware)
        
        print("  ‚úì middleware.py updated with new auth support\n")
    
    def validate_migration(self):
        """Validate that migration was successful"""
        print("‚úÖ Validating migration...")
        
        checks = [
            (self.auth_dir / "auth_routes.py", "auth_routes.py created"),
            (self.auth_dir / "middleware.py", "middleware.py exists"),
            (self.backup_dir, "Backup directory created"),
        ]
        
        all_good = True
        for path, description in checks:
            if path.exists():
                print(f"  ‚úì {description}")
            else:
                print(f"  ‚úó {description} - FAILED")
                all_good = False
        
        if all_good:
            print("\nüéâ Migration completed successfully!\n")
            print("Next steps:")
            print("1. Review the generated auth_routes.py")
            print("2. Test login functionality")
            print("3. Test OAuth flow")
            print("4. If everything works, you can delete oauth_routes.py")
        else:
            print("\n‚ö†Ô∏è Migration completed with warnings. Please review manually.\n")
    
    def rollback(self):
        """Rollback migration by restoring from backup"""
        print("\nüîÑ Rolling back migration...")
        
        if not self.backup_dir.exists():
            print("  ‚úó No backup found to rollback from")
            return
        
        for backup_file in self.backup_dir.iterdir():
            target_file = None
            
            if backup_file.name == "oauth_routes.py":
                target_file = self.auth_dir / "oauth_routes.py"
            elif backup_file.name == "middleware.py":
                target_file = self.auth_dir / "middleware.py"
            elif backup_file.name == "app.py":
                target_file = self.project_root / "app" / "app.py"
            
            if target_file:
                shutil.copy2(backup_file, target_file)
                print(f"  ‚úì Restored {backup_file.name}")
        
        # Remove the generated auth_routes.py
        auth_routes = self.auth_dir / "auth_routes.py"
        if auth_routes.exists():
            auth_routes.unlink()
            print("  ‚úì Removed generated auth_routes.py")
        
        print("‚úÖ Rollback completed\n")
    
    def run(self, dry_run=False):
        """Execute the full migration"""
        if dry_run:
            print("\nüîç DRY RUN MODE - No changes will be made\n")
            print("Would perform the following steps:")
            print("1. Backup existing files")
            print("2. Merge OAuth routes with new auth system")
            print("3. Update middleware.py")
            print("4. Update app.py imports")
            print("5. Validate migration")
            print("\nRun with --execute to apply changes\n")
            return
        
        print("\nüöÄ Starting Authentication Migration\n")
        print("=" * 60)
        
        self.create_backup()
        self.merge_oauth_routes()
        self.update_middleware()
        self.update_app_imports()
        self.validate_migration()
        
        print("=" * 60)
        print(f"\nüíæ Backup saved at: {self.backup_dir}")
        print("   Keep this backup until you've confirmed everything works!\n")


def main():
    parser = argparse.ArgumentParser(description="Migrate authentication system")
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Preview changes without applying them'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Execute the migration'
    )
    parser.add_argument(
        '--rollback',
        action='store_true',
        help='Rollback to previous version'
    )
    parser.add_argument(
        '--project-root',
        default='.',
        help='Path to project root directory'
    )
    
    args = parser.parse_args()
    
    migration = AuthMigration(args.project_root)
    
    if args.rollback:
        migration.rollback()
    elif args.execute:
        migration.run(dry_run=False)
    else:
        migration.run(dry_run=True)


if __name__ == "__main__":
    main()